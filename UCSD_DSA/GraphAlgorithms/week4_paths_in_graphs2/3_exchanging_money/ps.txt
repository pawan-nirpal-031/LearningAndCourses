Task. Given an directed graph with possibly negative edge weights and with ğ‘› vertices and ğ‘š edges as well
as its vertex ğ‘ , compute the length of shortest paths from ğ‘  to all other vertices of the graph.
Input Format. A graph is given in the standard format.
Constraints. 1 â‰¤ ğ‘› â‰¤ 103, 0 â‰¤ ğ‘š â‰¤ 104, 1 â‰¤ ğ‘  â‰¤ ğ‘›, edge weights are integers of absolute value at most
109.
Output Format. For all vertices ğ‘– from 1 to ğ‘› output the following on a separate line:
âˆ™ â€œ*â€, if there is no path from ğ‘  to ğ‘¢;
âˆ™ â€œ-â€, if there is a path from ğ‘  to ğ‘¢, but there is no shortest path from ğ‘  to ğ‘¢ (that is, the distance
from ğ‘  to ğ‘¢ is âˆ’âˆ);
âˆ™ the length of a shortest path otherwise

the given c++ implementation works correctly with the following test cases but this fails with some hidden test cases that I am unable to see 

6 7
1 2 10
2 3 5
1 3 100
3 5 7
5 4 10
4 3 -18
6 1 -1
1

5 4
1 2 1
4 1 2
2 3 2
3 1 -5
4

my implementation : 

#include <bits/stdc++.h>
using namespace std;
using namespace std::chrono;
typedef unsigned long long int ull;
typedef long long int ll;
typedef long double ld;
#define Mod 1000000007
#define Infinity (ll)1e18
#define Append(a) push_back(a)
#define Pair(a,b) make_pair(a,b)
#define Clear(a) for(ll &x : a){x=0;}
#define Point(x) std::fixed<<setprecision(15)<<x
#define SetBits(x) __builtin_popcount(x);
#define DebugCase(i,x) cout<<"Case #"<<i<<": "<<x<<'\n'
#define FastIO ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define Status(b) (cout<<(b?"YES\n":"NO\n"));

struct edge{
  int from,to; 
  int w;
};

void computeMinDisances(vector<edge>&graph,vector<ll> &distance,int nodes,int src){
  distance[src] = 0;
  vector<bool> negetiveCycleNodes(nodes+1,false);
  for(int i = 1;i<nodes;i++){
    for(edge &e : graph){
      if(distance[e.from]+e.w < distance[e.to])
        distance[e.to] = distance[e.from] + e.w;
    }
  }
  bool doesNegCycleExist = false;
  for(edge &e : graph){
    if(distance[e.from]+e.w < distance[e.to]){
      negetiveCycleNodes[e.from] = negetiveCycleNodes[e.to] = true;
      distance[e.to] = distance[e.from] + e.w;
      doesNegCycleExist = true;
    }
  }
  for(int i = 1;i<=nodes;i++){
    if(negetiveCycleNodes[i]){
      cout<<"-\n";
    }else{
      if(distance[i]!=Mod)
        cout<<distance[i]<<"\n";
      else
        cout<<"*\n";
    }
  }
}

int main(){
  FastIO;
  int nodes,edges;
  cin>>nodes>>edges;
  vector<edge>graph;
  vector<ll>distance(nodes+1,Mod);
  for(int ed = 0;ed<edges;ed++){
    int from,to;
    ll weight;
    cin>>from>>to>>weight;
    edge e;
    e.from = from;
    e.to = to;
    e.w = weight;
    graph.push_back(e);
  }
  int src;
  cin>>src;
  computeMinDisances(graph,distance,nodes,src);
  return 0;
}